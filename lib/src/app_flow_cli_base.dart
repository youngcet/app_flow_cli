import 'dart:async';
import 'dart:io';
import 'package:app_flow_cli/src/constants.dart';
import 'package:console/console.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';
import 'package:args/args.dart';

/// Main configuration class for the AppFlow CLI tool
/// 
/// Handles project structure generation and cleanup operations based on YAML configurations.
/// Manages both default embedded configurations and user-provided custom configurations.
/// 
/// Usage:
/// - Generate structure: AppFlow.generate()
/// - Clean generated files: AppFlow.generate(clean: true)
class AppFlow {
  /// Default embedded YAML configuration for project structure
  /// Contains predefined folder structure and template files for:
  /// - Feature modules (splash, home)
  /// - Core architecture components
  /// - Localization setup
  /// - Asset management
  /// - Testing infrastructure
  static final String _defaultConfig = '''
folders:
  # Feature modules
  # Splash Screen
  - lib/features/
  - lib/features/splash/
  - lib/features/splash/presentation/
  - lib/features/splash/logic/

  # Home Screen
  - lib/features/home/
  - lib/features/home/presentation/
  - lib/features/home/logic/
  
  # Routes
  - lib/features/routes/
  - lib/features/routes/logic/

  # Core functionality
  - lib/core/
  - lib/core/services/
  - lib/core/utils/
  
  # Localization
  - lib/l10n/
  
  # Static files
  - assets/icons/
  - assets/images/
  - assets/fonts/
  - assets/translations/
  
  # Testing
  - test/features/
  - test/mock/
  - test/test_helpers/
  
  # Other
  - integration_test/
  - scripts/

files:    
  lib/features/routes/logic/router.dart: |
    // AUTO-GENERATED CODE 
    // This file was automatically generated by the app flow structure generator
    import 'package:flutter/material.dart';
    
    import '../../splash/presentation/splash.dart';     // splash screen
    import '../../home/presentation/home.dart';         // home screen

    /// Centralized route management class for the application
    /// Handles route generation and navigation methods
    /// 
    /// [Auto-Generated] This class is automatically maintained by the app flow structure generator
    class Routes {
      static const String splash = '/';    // Initial route
      static const String home = '/home';     // Main screen after splash
      static const String notFound = '/404';    // 404 error page

      /// Generates routes based on route settings
      /// [settings] Contains route name and arguments
      /// Returns configured MaterialPageRoute
      static Route<dynamic> generateRoute(RouteSettings settings) {
        switch (settings.name) {
          case splash:
            return MaterialPageRoute(builder: (_) => const SplashScreen());     // Splash screen widget
          case home:
            return MaterialPageRoute(builder: (_) => const HomeScreen());       // Main application screen
          default:
            return MaterialPageRoute(builder: (_) => const RouteNotFound());    // 404 error page
        }
      }

      /// Navigates to a new screen while keeping previous in stack
      /// [context] Build context for navigation
      /// [routeName] Target route from Routes constants
      /// [arguments] Optional data to pass to new route
      static void push(BuildContext context, String routeName, {Object? arguments}) {
        Navigator.pushNamed(context, routeName, arguments: arguments);
      }

      /// Replaces current screen with new route
      /// [context] Build context for navigation
      /// [routeName] Target route from Routes constants
      /// [arguments] Optional data to pass to new route
      static void replace(BuildContext context, String routeName, {Object? arguments}) {
        Navigator.pushReplacementNamed(context, routeName, arguments: arguments);
      }

      /// Clears navigation stack and makes new route first
      /// [context] Build context for navigation
      /// [routeName] Target route from Routes constants
      /// [arguments] Optional data to pass to new route
      static void makeFirst(BuildContext context, String routeName, {Object? arguments}) {
        Navigator.pushNamedAndRemoveUntil(
          context,
          routeName,
          (route) => false,
          arguments: arguments,
        );
      }
    } 

    /// Default 404 error page displayed for unknown routes
    class RouteNotFound extends StatelessWidget {
      const RouteNotFound({super.key});

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: const Text('Page Not Found')),
          body: const Center(
            child: Text('The requested page does not exist'),
          ),
        );
      }
    }
  
  lib/features/splash/presentation/splash.dart: |
    // AUTO-GENERATED CODE 
    // This file was automatically generated by the app flow structure generator
    import 'dart:async';
    import 'package:flutter/material.dart';

    import '../../routes/logic/router.dart';

    class SplashScreen extends StatefulWidget {
      const SplashScreen({super.key});

      @override
      State<SplashScreen> createState() => _SplashScreenState();
    }

    class _SplashScreenState extends State<SplashScreen> {
      @override
      void initState() {
        super.initState();
        Timer(
          const Duration(seconds: 3),
          () => Routes.makeFirst(context, Routes.home)
        );
      }

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          body: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  Color(0xFF0A0E21),
                  Color(0xFF1D1E33),
                ],
              ),
            ),
            child: Stack(
              children: [
                // Background code snippets
                Positioned(
                  top: 100,
                  left: 20,
                  child: Opacity(
                    opacity: 0.1,
                    child: Text(
                      'const code = "Flutter";',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                            fontFamily: 'FiraCode',
                          ),
                    ),
                  ),
                ),
                
                // Main content
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      AnimatedOpacity(
                        opacity: 1,
                        duration: const Duration(milliseconds: 500),
                        child: const Icon(
                          Icons.code,
                          size: 100,
                          color: Colors.tealAccent,
                        ),
                      ),
                      const SizedBox(height: 20),
                      ShaderMask(
                        shaderCallback: (bounds) => const LinearGradient(
                          colors: [Colors.blue, Colors.tealAccent],
                        ).createShader(bounds),
                        child: const Text(
                          'App Flow CLI',
                          style: TextStyle(
                            fontSize: 32,
                            fontWeight: FontWeight.bold,
                            fontFamily: 'FiraCode',
                            color: Colors.white,
                          ),
                        ),
                      ),
                      const SizedBox(height: 10),
                      const Text(
                        'Building scalable structures',
                        style: TextStyle(
                          color: Colors.white70,
                          fontSize: 16,
                        ),
                      ),
                    ],
                  ),
                ),
                
                // Loading indicator
                Positioned(
                  bottom: 50,
                  left: 0,
                  right: 0,
                  child: LinearProgressIndicator(
                    backgroundColor: Colors.white24,
                    valueColor: AlwaysStoppedAnimation<Color>(
                      Colors.tealAccent.withOpacity(0.6),
                    ),
                    minHeight: 2,
                  ),
                ),
              ],
            ),
          ),
        );
      }
    }

  lib/features/home/presentation/home.dart: |
    // AUTO-GENERATED CODE 
    // This file was automatically generated by the app flow structure generator
    import 'dart:async';
    import 'package:flutter/material.dart';

    class HomeScreen extends StatefulWidget {
      const HomeScreen({super.key});

      @override
      State<HomeScreen> createState() => _HomeScreenState();
    }

    class _HomeScreenState extends State<HomeScreen> {
      @override
      void initState() {
        super.initState();
      }

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          body: Center(
            child: const Text('Home Page', style: TextStyle(color: Colors.white),)
          ),
        );
      }
    }

  lib/main.dart: |
    // AUTO-GENERATED CODE 
    // This file was automatically generated by the app flow structure generator
    import 'package:flutter/material.dart';

    import 'features/routes/logic/router.dart';

    void main() {
      runApp(const MyApp());
    }

    class MyApp extends StatelessWidget {
      const MyApp({super.key});

      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'App Flow CLI',
          initialRoute: Routes.splash,
          onGenerateRoute: Routes.generateRoute,
          theme: ThemeData.dark().copyWith(
            scaffoldBackgroundColor: const Color(0xFF0A0E21),
            textTheme: const TextTheme().apply(
              fontFamily: 'FiraCode',
            ),
          ),
        );
      }
    }
    
  lib/l10n/app_en.arb: |
    {
      "appTitle": "My App",
      "@appTitle": {
        "description": "The title of the application"
      }
    }
''';

  /// Main entry point for generating or cleaning project structure
  /// Handles both creation and cleanup operations based on parameters
  static Future<void> generate({
    String configPath = 'app_flow_cli.yaml',
    String add = 'structure',
    bool overwrite = false,
    bool clean = false,
  }) async {
    String targetPath = ''; // root directory
    
    if (add == AppFlowConstants.structure && !clean){
      final externalConfig = await _loadConfig(configPath);
      final config = externalConfig ?? _parseDefaultConfig();

      final folders = (config['folders'] as List).map((e) => e.toString()).toList();
      final files = Map<String, String>.fromEntries(
        (config['files'] as Map).entries.map((e) => 
          MapEntry(e.key.toString(), e.value.toString()),
      ));

      print('Adding ${folders.length + files.length} items...');

      await _createFolders(targetPath, folders);
      await _createFiles(targetPath, files, overwrite);
    }
    
    if (clean) {
      await _cleanGenerated(configPath);
      return;
    }

    if (add == AppFlowConstants.comments){
      String? filecontents = await _loadDartFileAsString('lib/features/home/presentation/home.dart');
      print('filecontents: $filecontents');
      return;
    }
  }

  /// Parses the default embedded YAML configuration
  /// Converts YAML structure to Dart native types
  static Map<String, dynamic> _parseDefaultConfig() {
    final yaml = loadYaml(_defaultConfig);
    return _yamlToDart(yaml);
  }

  /// Recursively converts YAML nodes to Dart objects
  /// Handles YamlMap, YamlList, and YamlScalar types
  static dynamic _yamlToDart(dynamic node) {
    if (node is YamlMap) {
      return Map<String, dynamic>.fromIterables(
        node.keys.map((k) => k.toString()),
        node.values.map(_yamlToDart),
      );
    }
    if (node is YamlList) {
      return node.map(_yamlToDart).toList();
    }
    if (node is YamlScalar) {
      return node.value;
    }
    return node.toString();
  }

  /// Loads external YAML configuration file
  /// Returns null if file not found or invalid
  static Future<Map<String, dynamic>?> _loadConfig(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        final content = await file.readAsString();
        return _yamlToDart(loadYaml(content));
      }
    } catch (e) {
      stderr.writeln('Config Error: $e');
    }
    return null;
  }

  /// Creates directories from folder paths
  /// Skips existing folders unless overwrite is true
  static Future<void> _createFolders(
    String root,
    List<String> folders,
  ) async {
    print('Creating ${folders.length} folders...');
    var progress = ProgressBar();
    var i = 0;
    for (final folder in folders) {
      i++;
      double progresscount = (i / folders.length) * 100;
      progress.update(progresscount.toInt());
      //print(progresscount.toInt());
      final dir = Directory(path.join(root, folder));
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
    }
  }

  /// Creates files with specified content
  /// Overwrites existing files if [overwrite] is true
  static Future<void> _createFiles(
    String root,
    Map<String, String> files,
    bool overwrite,
  ) async {
    print('Creating ${files.length} files...');
    var progress = ProgressBar();
    var i = 0;
    for (final entry in files.entries) {
      final file = File(path.join(root, entry.key));

      i++;
      double progresscount = (i / files.length) * 100;
      progress.update(progresscount.toInt());

      if (!await file.exists() || overwrite) {
        await file.create(recursive: true);
        await file.writeAsString(entry.value);
        // print('${overwrite ? 'Overwrote' : 'Created'}: ${file.path}');
      }
    }
  }

  /// Cleans up generated files and folders based on configuration
  /// WARNING: Potentially destructive operation
  static Future<void> _cleanGenerated(String configPath) async {
    final externalConfig = await _loadConfig(configPath);
    final config = externalConfig ?? _parseDefaultConfig();
  
    final folders = (config['folders'] as List).map((e) => e.toString()).toList();
    final files = Map<String, String>.fromEntries(
      (config['files'] as Map).entries.map((e) => 
        MapEntry(e.key.toString(), e.value.toString()),
    ));

    var totalitems = folders.length + files.length;
    if (externalConfig == null){
      totalitems += AppFlowConstants.additionFolders.length;
    }
    print('Cleaning $totalitems items...');

    var progress = ProgressBar();
    var i = 0;
    // Reverse to clean files before folders
    for (final entry in files.entries){
      String path = entry.key;
      final file = File(path);

      i++;
      double progresscount = (i / totalitems) * 100;
      progress.update(progresscount.toInt());

      if (await file.exists() && !path.contains('main.dart')) {
        try {
          await file.delete(recursive: true);
        } catch (e) {
          stderr.writeln('Error removing $path: $e');
        }
      }
    }
    
    // add additional folder to remove
    folders.addAll(AppFlowConstants.additionFolders);
    
    for (final folder in folders){
      final dir = Directory(folder);

      i++;
      double progresscount = (i / totalitems) * 100;
      progress.update(progresscount.toInt());

      if (await dir.exists()){
        try {
          await dir.delete(recursive: true);
        } catch (e) {
          stderr.writeln('Error removing $folder: $e');
        }
      }
    }
  }

  /// Loads the contents of a Dart file as a string
  /// 
  /// [filePath] : Path to the Dart file (relative or absolute)
  /// Returns file contents as String or null if file not found
  static Future<String?> _loadDartFileAsString(String filePath) async {
    try {
      final file = File(filePath);
      
      // Verify file exists and has .dart extension
      if (await file.exists() && filePath.endsWith('.dart')) {
        return await file.readAsString();
      }
      
      stderr.writeln('File not found or invalid type: $filePath');
      return null;
    } catch (e) {
      stderr.writeln('Error reading file $filePath: $e');
      return null;
    }
  }
}